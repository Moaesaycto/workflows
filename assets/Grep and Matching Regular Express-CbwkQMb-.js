const e="# Grep and Matching Regular Expressions on the Command Line\r\n\r\n`grep` is used to search for patterns in text.\r\n`-E` enables extended regex\r\n\r\nUse the command as follows:\r\n\r\n```bash\r\ngrep -E <expression> <filename>\r\n```\r\n\r\nFor example:\r\n\r\n```bash\r\ngrep -E '[0-9]{3}-[0-9]{3}-[0-9]{4}' file.txt\r\n```\r\n\r\nThis page will have a list of the basics of the rules you should know:\r\n\r\n- `|`: Alternation uses the pipe character, matching one OR another. For example:\r\n\r\n```bash\r\ngrep -E 'cat|dog' file.txt\r\n```\r\n\r\n## Useful Keywords\r\n| Option | Description                      |\r\n| ------ | -------------------------------- |\r\n| `-i`   | Ignore case                      |\r\n| `-v`   | Invert match                     |\r\n| `-E`   | Use extended regex               |\r\n| `-r`   | Recursively search directories   |\r\n| `-n`   | Show line numbers                |\r\n| `-c`   | Show match count                 |\r\n| `-o`   | Only print matching part of line |\r\n| `-w`   | Match whole words only           |\r\n| `-x`   | Match whole line only            |\r\n| `-A N` | Show N lines **after** match     |\r\n| `-B N` | Show N lines **before** match    |\r\n| `-C N` | Show N lines **around** match    |\r\n\r\n\r\n## Grouping\r\n\r\n- `()`: Grouping uses parentheses for group patterns, such as `gr(a|e)y` to match `grey` and `gray`.\r\n\r\n- `[]`: For lists of characters, you use brackets, so `[abc]` would be the letters `a`, `b` and `c`. `[a-z]` is the lowercase letters of the alphabet, `[A-Z]` is the uppercase letters, and `[a-zA-Z]` is both. Doing `[^abc]` is everything that isn't in the list (not `a`, `b` or `c`).\r\n\r\n## Beginning and Ends\r\n\r\n- `^`: At the start of a string, use caret, so for example, if you don't want words starting with a vowel, you use `^[^adieu]`. \r\n- `$`: Use a dollar sign at the end, so words that do not end with a vowel should be `[^aeiou]$`.\r\n\r\n## Repetition\r\n\r\n- `*`: Adding an asterisk means it's repeated indefinitely. So for example, a word that is only made from vowels would be `[aeiou]*`.\r\n- `.`: Full stop (or period) is to represent any character, so typing `.*` basically means any character for an arbitrary amount.\r\n- `?`: Question mark is for zero or one times (think of it as a single, optional character)\r\n- `+`: Plus sign is for one or more\r\n- `{}`: Using braces allows you to define how may times something is expected, for example, `{3}` means three times, `{2, 5}` means between two and five (inclusive), and `{2,}` means two or more.\r\n\r\n## Perl-Compatible Regex (PCRE)\r\n\r\n* **Lookaheads / Lookbehinds**\r\n\r\n  * `(?=...)` – Match if followed by something\r\n    · `\\w+(?=\\d)` → Matches `item` in `item1`\r\n  * `(?<=...)` – Match if preceded by something\r\n    · `(?<=@)\\w+` → Matches `domain` in `user@domain`\r\n  * `(?!...)` – Match if **not** followed by something\r\n    · `foo(?!bar)` → Matches `foo` not followed by `bar`\r\n  * `(?<!...)` – Match if **not** preceded by something\r\n    · `(?<!\\$)\\d+` → Matches `30` in `$50 30`\r\n\r\n* **Non-capturing groups**\r\n\r\n  * `(?:...)` → group without saving a match\r\n    · `(?:foo|bar)baz` → Matches `foobaz` and `barbaz`, no capture\r\n\r\n* **Named capture groups**\r\n\r\n  * `(?<name>...)` → assign a name to a captured group\r\n    · `(?<area>\\d{3})-(?<num>\\d{3}-\\d{4})` → Matches `123-456-7890` with named groups\r\n\r\n* **Lazy quantifiers**\r\n\r\n  * `*?`, `+?`, `??` → non-greedy matching\r\n    · `<.*?>` → Matches `<b>` in `<b>bold</b>` instead of the whole tag pair\r\n\r\n* **Unicode properties**\r\n\r\n  * `\\p{L}`, `\\p{N}` → match letters, numbers, etc.\r\n    · `\\p{L}+` → Matches `café` including `é`\r\n    · `\\p{N}+` → Matches `١٢٣` (Arabic numerals)\r\n\r\n* **Backreferences in lookaheads**\r\n\r\n  * Use captured groups inside lookaheads\r\n    · `\\b(\\w+)(?=.*\\1\\b)` → Matches `cat` in `cat dog cat` (appears again later)\r\n\r\n* **Enhanced escape sequences**\r\n\r\n  * `\\R` → any line break (handles `\\n`, `\\r\\n`, etc.)\r\n    · `Line1\\RLine2` → Matches across systems\r\n  * `\\K` → reset match start (ignore earlier part)\r\n    · `foo\\Kbar` → Matches only `bar` (ignores `foo` in result)\r\n\r\n* **Conditional expressions**\r\n\r\n  * `(?(1)yes|no)` → conditional match based on group 1\r\n    · `(abc)?(?(1)123|456)`\r\n    Matches `abc123` if `abc` is present, `456` if not\r\n\r\n* **Recursive patterns**\r\n\r\n  * `(?1)`, `(?&name)` → recursive call to a numbered or named group\r\n    · `^(A(?1)?B)$` → Matches exactly `n` A’s followed by `n` B’s\r\n    · Enables balanced or nested structures using pure regex\r\n";export{e as default};
