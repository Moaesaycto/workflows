const e='# Curl, WGet and JQ for Web-Scraping\r\n\r\n`curl` (Client URL) and `wget` (Web Get) are used to send requests. Below is a table with the basic commands\r\n\r\n| Task                | `curl`                   | `wget`                       |\r\n| ------------------- | ------------------------ | ---------------------------- |\r\n| Simple download     | `curl -O URL`            | `wget URL`                   |\r\n| Custom filename     | `curl -o file URL`       | `wget -O file URL`           |\r\n| Follow redirects    | `curl -L URL`            | `wget URL` (default follows) |\r\n| POST request        | `curl -X POST -d ...`    | *(Not ideal — use curl)*     |\r\n| Recursive site grab | *(Not ideal — use wget)* | `wget -r URL`                |\r\n\r\n## JQ (JSON Query Tool)\r\n\r\n`jq` is just a general tool for working with JSON objects. Here are the basics:\r\n\r\n| Task           | Command                       |\r\n| -------------- | ----------------------------- |\r\n| Pretty print   | `jq .`                        |\r\n| Get key        | `jq \'.key\'`                   |\r\n| Nested key     | `jq \'.a.b.c\'`                 |\r\n| Filter array   | `jq \'.\\[] \\| select(.x > 5)\'` |\r\n| Extract fields | `jq \'.\\[] \\| {id, name}\'`     |\r\n| From curl      | `curl ... \\| jq \'.\'`          |\r\n\r\nYou can use `jq` right after `curl` or `wget`, like so:\r\n\r\n```bash\r\ncurl -s https://api.example.com/data | jq \'.key\'\r\n```\r\n\r\n### Array Access and Manipulation in JQ\r\n\r\n| Syntax                               | Description                            |\r\n| ------------------------------------ | -------------------------------------- |\r\n| `.[0]`                               | First element                          |\r\n| `.[-1]`                              | Last element                           |\r\n| `.[0:2]`                             | Slice: index 0 to 1                    |\r\n| `.[2:]`                              | Slice: from index 2 to end             |\r\n| `.[-3:]`                             | Last 3 elements                        |\r\n| `.[0,2,4]`                           | Specific indexes                       |\r\n| `\\[.\\[] \\| select(.age > 30)]`       | Filter items into new array            |\r\n| `\\[.\\[] \\| .name]`                   | Extract field `.name` from each object |\r\n| `\\[.\\[] \\| select(.ok == true)]\\[0]` | First item where condition is true     |\r\n| `map(.name)`                         | Shorthand for field extraction         |\r\n| `map(select(.score > 50))`           | Filter using `map()`                   |\r\n| `any(.[]; .id == 1)`                 | Returns true if any match              |\r\n| `index("b")`                         | Index of value `"b"`                   |\r\n| `map(.name == "foo") \\| index(true)` | Index of first match by condition      |\r\n| `sort_by(.score)`                    | Sort array of objects by key           |\r\n\r\n### JQ Variables and Arguments\r\nIn order to use arguments, use the structure `--arg name value`. For example, \r\n\r\n```bash\r\njq --arg varname "$shell_var" \'... use $varname ...\'\r\n```\r\n\r\nThis will replace the `$varname` string with the desired variable. Repeat this for all arguments needed.\r\n### Filtering\r\n\r\nFiltering uses the `select()` and `test()` functions:\r\n```bash\r\njq \'.data[] | select(.type == "Course")\'\r\n```\r\n\r\nYou can also use `and`, `or` and `not` keywords, such as:\r\n\r\n```bash\r\nselect(.type == "Course" and (.code | test("^COMP")))\r\nselect(.type == "Course" or .type == "Program") \r\nselect((.code | test("^BIOC")) | not)\r\n```\r\n\r\nYou can use Regex to filter based on the actual attribute. For example:\r\n```bash\r\nselect(.code | test("^COMP[0-9]{4}"))\r\n```\r\n\r\nOf course, you can handle these externally if needed, using variables:\r\n\r\n```bash\r\njq --arg code "^COMP[0-9]{4}" \'select(.code | test($code))\'\r\n```\r\n\r\n| Function           | Purpose                           | Example                            |\r\n| ------------------ | --------------------------------- | ---------------------------------- |\r\n| `select(...)`      | Filters based on condition        | `select(.code == "COMP1531")`      |\r\n| `test("regex")`    | Regex match for strings           | `select(.code \\| test("^COMP"))`   |\r\n| `and`, `or`, `not` | Logical operations                | `select(.a == 1 and .b == 2)`      |\r\n| `.field[]`         | Index into arrays                 | `.lines[0] == "Course"`            |\r\n| `.field?`          | Safe access (no error if missing) | `select(.optional?)`               |\r\n\r\n\r\n## Fallback\r\n\r\nIf you are worried something does not exist, you can use a fallback by doing `.field1 // .field2`. For example:\r\n\r\n```bash\r\n\'| select((.code // .filename) | test(\\$code))\'\r\n```\r\n\r\n## Substitutions (`gsub`)\r\n`gsub` is used to replace characters in `jq` commands. The usage is as follows:\r\n\r\n```bash\r\ngsub("pattern"; "replacement")\r\n```\r\n\r\nFor example:\r\n\r\n```bash\r\n"a\\nb\\r\\nc" | gsub("[\\n\\r]+"; " ") # ->  "a b c"\r\n```\r\n\r\n### Making it Shell Compatible\r\nSuppose you want to format it into a string that you can use outside of JQ. To do this, we want to be using the raw output, which is with `-r`.\r\n\r\nTo create the strings you\'re used to working with, at the very end of your query, set them by referring to them as follows:\r\n\r\n```bash\r\n"\\(.field1) \\(.field2)"\r\n```\r\nFrom there, you are able to safely pass them into the desired UNIX commands. For example:\r\n\r\n```bash\r\ncurl -sL "$url" | jq -r \'.[]| "\\(.code) \\(.title)\' | sort | uniq\r\n```';export{e as default};
